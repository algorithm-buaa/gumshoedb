// WARNING: AUTOGENERATED CODE
// Do not edit by hand (see gen.go).

package gumshoe

import (
	"math"
	"unsafe"
)

type Type int

const (
	TypeUint8   Type = iota
	TypeInt8    Type = iota
	TypeUint16  Type = iota
	TypeInt16   Type = iota
	TypeUint32  Type = iota
	TypeInt32   Type = iota
	TypeFloat32 Type = iota
)

var typeWidths = []int{
	TypeUint8:   int(unsafe.Sizeof(uint8(0))),
	TypeInt8:    int(unsafe.Sizeof(int8(0))),
	TypeUint16:  int(unsafe.Sizeof(uint16(0))),
	TypeInt16:   int(unsafe.Sizeof(int16(0))),
	TypeUint32:  int(unsafe.Sizeof(uint32(0))),
	TypeInt32:   int(unsafe.Sizeof(int32(0))),
	TypeFloat32: int(unsafe.Sizeof(float32(0))),
}

var typeMaxes = []float64{
	TypeUint8:   math.MaxUint8,
	TypeInt8:    math.MaxInt8,
	TypeUint16:  math.MaxUint16,
	TypeInt16:   math.MaxInt16,
	TypeUint32:  math.MaxUint32,
	TypeInt32:   math.MaxInt32,
	TypeFloat32: math.MaxFloat32,
}

var typeNames = []string{
	TypeUint8:   "uint8",
	TypeInt8:    "int8",
	TypeUint16:  "uint16",
	TypeInt16:   "int16",
	TypeUint32:  "uint32",
	TypeInt32:   "int32",
	TypeFloat32: "float32",
}

var NameToType = map[string]Type{
	"uint8":   TypeUint8,
	"int8":    TypeInt8,
	"uint16":  TypeUint16,
	"int16":   TypeInt16,
	"uint32":  TypeUint32,
	"int32":   TypeInt32,
	"float32": TypeFloat32,
}

// add adds other to m (only m is modified).
func (m MetricBytes) add(s *Schema, other MetricBytes) {
	p1 := uintptr(unsafe.Pointer(&m[0]))
	p2 := uintptr(unsafe.Pointer(&other[0]))
	for i, column := range s.MetricColumns {
		offset := uintptr(s.MetricOffsets[i])
		col1 := unsafe.Pointer(p1 + offset)
		col2 := unsafe.Pointer(p2 + offset)
		switch column.Type {
		case TypeUint8:
			*(*uint8)(col1) = *(*uint8)(col1) + (*(*uint8)(col2))
		case TypeInt8:
			*(*int8)(col1) = *(*int8)(col1) + (*(*int8)(col2))
		case TypeUint16:
			*(*uint16)(col1) = *(*uint16)(col1) + (*(*uint16)(col2))
		case TypeInt16:
			*(*int16)(col1) = *(*int16)(col1) + (*(*int16)(col2))
		case TypeUint32:
			*(*uint32)(col1) = *(*uint32)(col1) + (*(*uint32)(col2))
		case TypeInt32:
			*(*int32)(col1) = *(*int32)(col1) + (*(*int32)(col2))
		case TypeFloat32:
			*(*float32)(col1) = *(*float32)(col1) + (*(*float32)(col2))
		}
	}
}

func setRowValue(pos unsafe.Pointer, typ Type, value float64) {
	switch typ {
	case TypeUint8:
		*(*uint8)(pos) = uint8(value)
	case TypeInt8:
		*(*int8)(pos) = int8(value)
	case TypeUint16:
		*(*uint16)(pos) = uint16(value)
	case TypeInt16:
		*(*int16)(pos) = int16(value)
	case TypeUint32:
		*(*uint32)(pos) = uint32(value)
	case TypeInt32:
		*(*int32)(pos) = int32(value)
	case TypeFloat32:
		*(*float32)(pos) = float32(value)
	}
}

// numericCellValue decodes a numeric value from cell based on typ. It does not look into any dimension
// tables.
func (s *State) numericCellValue(cell unsafe.Pointer, typ Type) Untyped {
	switch typ {
	case TypeUint8:
		return *(*uint8)(cell)
	case TypeInt8:
		return *(*int8)(cell)
	case TypeUint16:
		return *(*uint16)(cell)
	case TypeInt16:
		return *(*int16)(cell)
	case TypeUint32:
		return *(*uint32)(cell)
	case TypeInt32:
		return *(*int32)(cell)
	case TypeFloat32:
		return *(*float32)(cell)
	}
	panic("unexpected type")
}

// UntypedToFloat64 converts u to a float, if it is some int or float type. Otherwise, it panics.
func UntypedToFloat64(u Untyped) float64 {
	switch n := u.(type) {
	case uint8:
		return float64(n)
	case int8:
		return float64(n)
	case uint16:
		return float64(n)
	case int16:
		return float64(n)
	case uint32:
		return float64(n)
	case int32:
		return float64(n)
	case float32:
		return float64(n)
	}
	panic("unexpected type")
}

// UntypedToInt converts u to an int, if it is some integer type. Otherwise, it panics.
func UntypedToInt(u Untyped) int {
	switch n := u.(type) {
	case uint8:
		return int(n)
	case int8:
		return int(n)
	case uint16:
		return int(n)
	case int16:
		return int(n)
	case uint32:
		return int(n)
	case int32:
		return int(n)
	}
	panic("not an integer type")
}

// Query helper functions

type FilterType int

const (
	FilterEqual              FilterType = iota
	FilterNotEqual           FilterType = iota
	FilterGreaterThan        FilterType = iota
	FilterGreaterThenOrEqual FilterType = iota
	FilterLessThan           FilterType = iota
	FilterLessThanOrEqual    FilterType = iota
	FilterIn                 FilterType = iota
)

var filterTypeToName = []string{
	FilterEqual:              "=",
	FilterNotEqual:           "!=",
	FilterGreaterThan:        ">",
	FilterGreaterThenOrEqual: ">=",
	FilterLessThan:           "<",
	FilterLessThanOrEqual:    "<=",
	FilterIn:                 "in",
}

var filterNameToType = map[string]FilterType{
	"=":  FilterEqual,
	"!=": FilterNotEqual,
	">":  FilterGreaterThan,
	">=": FilterGreaterThenOrEqual,
	"<":  FilterLessThan,
	"<=": FilterLessThanOrEqual,
	"in": FilterIn,
}

var typeToSumFunc = map[Type]func(offset int) sumFunc{
	TypeUint8: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeInt8: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeUint16: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeInt16: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeUint32: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeInt32: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
	TypeFloat32: func(offset int) sumFunc {
		return func(sum UntypedBytes, metrics MetricBytes) {
			*(*uint32)(unsafe.Pointer(&sum[0])) += *(*uint32)(unsafe.Pointer(&metrics[offset]))
		}
	},
}

type typeAndFilter struct {
	Type   Type
	Filter FilterType
}

var typeAndFilterToMetricFilterFuncSimple = map[typeAndFilter]func(value float64, offset int) filterFunc{

	typeAndFilter{TypeUint8, FilterEqual}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeUint8, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeUint8, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeUint8, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeUint8, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeUint8, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := uint8(value)
		return func(row RowBytes) bool {
			return *(*uint8)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeInt8, FilterEqual}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeInt8, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeInt8, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeInt8, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeInt8, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeInt8, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := int8(value)
		return func(row RowBytes) bool {
			return *(*int8)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeUint16, FilterEqual}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeUint16, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeUint16, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeUint16, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeUint16, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeUint16, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := uint16(value)
		return func(row RowBytes) bool {
			return *(*uint16)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeInt16, FilterEqual}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeInt16, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeInt16, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeInt16, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeInt16, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeInt16, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := int16(value)
		return func(row RowBytes) bool {
			return *(*int16)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeUint32, FilterEqual}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeUint32, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeUint32, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeUint32, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeUint32, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeUint32, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := uint32(value)
		return func(row RowBytes) bool {
			return *(*uint32)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeInt32, FilterEqual}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeInt32, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeInt32, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeInt32, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeInt32, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeInt32, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := int32(value)
		return func(row RowBytes) bool {
			return *(*int32)(unsafe.Pointer(&row[offset])) <= v
		}
	},
	typeAndFilter{TypeFloat32, FilterEqual}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) == v
		}
	},
	typeAndFilter{TypeFloat32, FilterNotEqual}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) != v
		}
	},
	typeAndFilter{TypeFloat32, FilterGreaterThan}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) > v
		}
	},
	typeAndFilter{TypeFloat32, FilterGreaterThenOrEqual}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) >= v
		}
	},
	typeAndFilter{TypeFloat32, FilterLessThan}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) < v
		}
	},
	typeAndFilter{TypeFloat32, FilterLessThanOrEqual}: func(value float64, offset int) filterFunc {
		v := float32(value)
		return func(row RowBytes) bool {
			return *(*float32)(unsafe.Pointer(&row[offset])) <= v
		}
	},
}
